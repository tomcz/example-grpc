package main

import (
	"context"
	"crypto/tls"
	"crypto/x509"
	"flag"
	"fmt"
	"os"

	log "github.com/sirupsen/logrus"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/metadata"
	"google.golang.org/protobuf/encoding/protojson"

	"github.com/tomcz/example-grpc/api"
)

var (
	useToken = flag.String("token", "", "use this token for bearer authentication")
	useAlice = flag.Bool("alice", false, "use Alice's certificate & key for TLS authentication")
	useBob   = flag.Bool("bob", false, "use Bob's certificate & key for TLS authentication")
	addr     = flag.String("addr", "localhost:8000", "server address")
	msg      = flag.String("msg", "", "message to send")
)

func main() {
	flag.Parse()
	// Fatal logging prevents defer from firing, so wrap the
	// service configuration & startup in a realMain function.
	if err := realMain(); err != nil {
		log.WithError(err).Fatal("application failed")
	}
	log.Info("application stopped")
}

func realMain() error {
	tc, err := newTransportCredentials()
	if err != nil {
		return err
	}

	conn, err := grpc.Dial(*addr, grpc.WithTransportCredentials(tc))
	if err != nil {
		return fmt.Errorf("failed to dial: %w", err)
	}
	defer conn.Close()

	ctx := context.Background()
	if *useToken != "" {
		md := metadata.Pairs("authorization", fmt.Sprintf("Bearer %s", *useToken))
		ctx = metadata.NewOutgoingContext(ctx, md)
	}

	client := api.NewExampleClient(conn)
	res, err := client.Echo(ctx, &api.EchoRequest{Message: *msg})
	if err != nil {
		return fmt.Errorf("echo request failed: %w", err)
	}

	fmt.Println(protojson.Format(res))
	return nil
}

func newTransportCredentials() (credentials.TransportCredentials, error) {
	if *useAlice || *useBob {
		return newMTLSTransportCredentials()
	}
	return credentials.NewClientTLSFromFile("target/ca.crt", "server.example.com")
}

func newMTLSTransportCredentials() (credentials.TransportCredentials, error) {
	// 1. Verify that the server's certificate was generated by our trusted CA.
	caCert, err := os.ReadFile("target/ca.crt")
	if err != nil {
		return nil, fmt.Errorf("cannot read root CA cert: %w", err)
	}
	caCertPool := x509.NewCertPool()
	if !caCertPool.AppendCertsFromPEM(caCert) {
		return nil, fmt.Errorf("failed to add root CA cert into cert pool")
	}

	// 2. Whose certificate & key should we use to authenticate with the server?
	var certFile, keyFile string
	if *useAlice {
		certFile = "target/alice.crt"
		keyFile = "target/alice.key"
	}
	if *useBob {
		certFile = "target/bob.crt"
		keyFile = "target/bob.key"
	}
	cert, err := tls.LoadX509KeyPair(certFile, keyFile)
	if err != nil {
		return nil, fmt.Errorf("failed to load cert & key files: %w", err)
	}

	// 3. Configure mutual TLS authentication with the server.
	cfg := &tls.Config{
		RootCAs:      caCertPool,
		Certificates: []tls.Certificate{cert},
		ServerName:   "server.example.com",
	}
	return credentials.NewTLS(cfg), nil
}
